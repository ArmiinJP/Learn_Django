MVT model view template
MVC model controller  

User -> Url -> view (Model, Template)
Model : connecting to Database
template: for display data from backend to user 

از طریق view به عنوان یک فانکشن اطلاعات را از کاربر گرفته و حالا نوبت به ارتباط با دیتابیس از طریق model و سپس وقتی دیتاها را از دیتابیس گرفتم، و لازم بود چیزی به کاربر نمایش دهم، از طریق template این کار را انجام میدم. 
ممکن است با model کاری نداشته باشید و لازم باشه صرفا یک صفحه‌ی ساده را براش بنویسید.
----------------------------------------------
معماری MVC برای مدت طولانی در صنعت نرم افزار وجود داشته است. اکثر زبان‌های برنامه‌نویسی با تغییراتی جزئی معماری MVC را پیاده سازی میکنند. این معماری هر برنامه را به سه بخش تقسیم میکند. 

کامپوننت model ساختار اطلاعات ذخیره شده در دیتابیس را مشخص میکند. برای اتصال به دیتابیس و کار کردن با داده‌ها باید از model استفاده کنید. این بخش میتواند برای تبادل اطلاعات با دو بخش دیگر همکاری کند. model در این معماری با model جنگو یکسان است.

بخش view رابطی است که کاربر نهایی با آن سروکار دارد. در این بخش اطلاعات را از بخش model گرفته و به کاربر نمایش میدهیم، همچنین در این بخش میتوانیم اطلاعات را از کاربر نهایی گرفته و به بخش‌های دیگر ارسال کنیم. view در این معماری با view جنگو متفاوت است که در ادامه به این تفاوت میپردازیم.

بخش controller مسئول انجام تمام عملیات‌هایی است که در پشت صحنه اتفاق میفتد. اگر کاربر درخواستی را ارسال کند، این درخواست ابتدا به controller رفته، پردازش شده و به بخش‌های دیگر ارسال میشود. نکته : کامپوننت controller میتواند اطلاعات را از model گرفته و در بخش view به کاربر نمایش دهد. در جنگو بخش controller نداریم.
----------------------------------------------
جنگو ترجیج میدهد معماری خودش را پیاده کند. معماری که جنگو از آن استفاده میکند MVT نام دارد که بسیار مشابه MVC است. MVT مخفف model-view-template است. 

دقیقا مشابه model در mvc، این بخش در جنگو هم مسئول مدیریت ساختار اطلاعات ذخیره شده در دیتابیس است. این model در جنگو با model معماری mvc هیچ تفاوتی ندارد

برخلاف معماری mvc که در آن view مسئول نمایش اطلاعات به کاربر نهایی بود، در جنگو این بخش مسئول پردازش درخواست‌ها است. این بخش رابطی‌ است که بخش‌های model و template را به هم وصل میکند. زمانی که کاربر درخواستی را ارسال میکند، درخواستش در این بخش پردازش شده و پاسخ مناسب به او نشان داده خواهد شد. میتوان گفت که view در جنگو همان controller است در معماری mvc.

کامپوننت templates معادل view است در معماری mvc. در این بخش نتیجه نهایی به کاربر نشان داده میشود. همچنین میتوانید در این بخش از کاربر اطلاعاتی را دریافت کرده و به دیگر بخش‌های ارسال کنید. نمایش templates جنگو وظیفه بخش view است. تمام فایل‌های استاتیک مانند فایل‌های html یا css در این بخش مدیریت میشوند.

مراحل :
۱. کاربر یک درخواست از طریق url به برنامه‌ جنگویی ارسال میکند.
۲. جنگو به دنبال یک url معتبر در خود میگردد.
۳. اگر url به view خاصی متصل باشد آنگاه آن view صدا زده خواهد شد.
۴. در صورت نیاز view به model متصل شده و اطلاعات مناسبی را دریافت خواهد کرد.
۵. در آخر view یک بخش از templates، همراه با اطلاعات دریافتی از model را به کاربر نمایش میدهد.
----------------------------------------------
کل پروژه را میگن project و بعد کل پروژه را تقسیم میکنن به app های کوچکتر
مثلا کل پروژه اگه وبسایت مونگارد باشه، بخش مثلا ویدئوهای تک قسمتی میشه یک app یک اپ برای کاربران ، یک اپ برای مقالات ، یک اپ برای دوره ها یک اپ برای کامنت ها و...
جنگو برای اینکه توسعه و نگهداری پروژه ها ساده تر باشه پروژه شما رو به اندازه های کوچکتر به نام app تقسیم میکنه. هر app یک وظیفه خاص رو داره. مثلا در پروژه وبلاگ، یک app وظیفه مدیریت مقالات، یک app دیگه وظیفه مدیریت نظرات، یک app دیگه وظیفه مدیریت کاربرها رو داره. در نتیجه اگه مشکلی در پروژه جنگویی شما پیش بیاد یا اگه بخواید امکانات جدیدی رو به برنامه تون اضافه کنید میدونید که باید کجا برید
A project is a collection of configuration and apps for a particular website. A project can contain multiple apps. An app can be in multiple projects
----------------------------------------------
ساخت یک پروژه ی جدید

۰. فعال کردن virtual environment
۱. دیدن ورژن جنگوی نصب شده در این venv:
$ python -m django --version
۲. زدن دستور زیر:
django-admin startproject YE_ESM .
۳. تست اجرای پروژه:
python manage.py runserver
or $ python manage.py runserver 8080
۴. اوکی کردن migrate پروژه ( که برای ذخیره‌ی اطلاعات در دیتابیس به صورت مرحله به مرحله می‌باشد.)
python manage.py migrate
۵. ساخت کاربر ادمین
python manage.py createsuperuser
۶. گفتیم در جنگو برای اینکه بتونیم یک برنامه‌ی بزرگ را ایجاد کنیم، یک پروژه را میشکنیم به اپهای جدیدتر، برای این کار کافیست دستور زیر را در جایی که میخواید اپ ایجاد بشه (که محلش میشه کنار manage.py اینا) از دستور زیر کمک بگیرید:
python manage.py startapp ESM_APP
پس از اینکه دستور بالا را بزنی، یک پوشه به اسم اپی که ایجاد کردی ساخته میشه، که فایلهای مختلفی در اون هست، برای مثال یکی از اون فایلها view.py هست، که ما میایم و view ها را اونجا مینویسیم. 
To create your app, make sure you’re in the same directory as manage.py and type this command
۸. اما نکته ای که هست الان درسته app امون را ساختیم ولی جنگو هنوز از این app خبر نداره، لذا میریم داخل پروژه و در قسمت settings.py  ، در بخش INSTALLED_APPS که یک لیستی از اپها در اون وجود داره، و شما باید اپ خودتون را به اخر این لیست اضافه کنید، کافیه اسم اپ را داخل ' ' بزارید و در انتهاش یک کاما
۹. همچنین مشکل دیگه‌ای که هست اون urls.py که در مسیر پروژه بود، مال خود پروژه هست، و برای اپها urls.py ایجاد نمیشه، پس باید خودمون برای اپهامون که ایجاد میشه، تو پوششون این فایل urls.py را بسازیم. 
۱۰. برای این که بیایم url های اپمون را داخل این urls.py ایجاد کنیم، دقیقا مشابه با urls.py سطح پروژه، به صورت زیر جلو میریم:
from django.urls import path
۱۱. سپس باید بیایم و پترنهای url هامون را مشخص کنیم که کافیه لیست زیر را ایجاد کنید و با فانکشن path که دو تا ورودی میگیره که ورودی اول اون ادامه‌ی url هست و اخرش هم / داره و بخش دوم باید view ای که به محض کال شدن این url باید فعال شود را بنویسید.
urlpattherns = [path('ESM/', TEST) ] 
مثال: خب فرض کنید یک تابع به اسم sayHello در view.py این اپ نوشتیم و حالا میخوایم url را تعریف کنیم و به این view وصلش کنیم
اول میایم views را به urls.py ایمپورتش میکنیم: (چون views.py کنار همون urls.py هست از . استفاده کردیم)
from . import views
سپس path زیر را به urlpatterns اضافه میکنیم:
urlpatterns = [path('hello/', views.sayHello), ]

۱۲. خب view چی هست؟ یک فانکشن پایتونی هست که یک ریکوئستی را میگیره و یک ریسپانسی را برمیگردونه، و  این ریسپانس میتواند هر چیزی باشد. 
تمام view هاتون مثل sayHello بالا، وقتی میخواید تعریفشون کنید، بدون استنثا ارگومان اولشون request هست. و سپس داخل فانکشن هر آن چیزی خواستید میتونید برگردونید(نمیشه چیزی چاپ کرد باید return کنید حتما)
https://docs.djangoproject.com/en/4.2/intro/tutorial01/#write-your-first-view
۱۳. خب view را که ساختی و وصلش کردی به url کار این url این اپ به اتمام رسیده
۱۴. باید url های این اپ را به جنگو بشناسونی، برای اینکار میری تو urls.py پروژه ات و با کمک include بهش میشناسونی.
    path('home/', include("home.urls")),
۱۵. خب چیزی که الان با view برگردوندیم تا به کاربر نشون بدیم یه HttpResponse بود که یک پاسخ خیلی ساده بود. ما لازم داریم که پاسخ های سنگین تری ارسال کنیم. که شامل عکس و ایناست. خب نقش template جنگو اینجا مشخص میشه، ضمنا بعضی ها از jinja2 هم برای این منظور استفاده میکنند.
اصولا پوشه‌ی اون را در کنار همون manage.py اینا داخل پوشه‌ای که اسمش هم دست خودت هست ولی templates براش عرف هست قرار میدند.
۱۶. باید بیاید و پوشه‌ی templalate ای که ایجاد کردید را به جنگو معرفی کنید، برید داخل setting.py در بخش templates که یک لیست هست، بخش BACKEND اش که مشخص میکنه از چه موتوری برای template هاتون استفاده میکنید، که پیش فرض مال جنگو هست ولی میشه jinja2 کرد.
در بخش مربوط به DIRS تو میتونی از BASE_DIR که به سطح اصلی پروژه اشاره میکنه استفاده کنی، و بعد هم پوشه‌ی  templates را بزنی که یعنی عملا میشه همون مسیر پروژه و بعد templates.
'DIRS': [BASE_DIR / 'templates']
از این به بعد جنگو این مسیر را میشناسی به عنوان جایی که ما template هامون را در اون ذخیره میکینم.
۱۶. حالا برمیگردیم به view که داشتیم اینبار دیگه میخوایم از template استفاده کنیم، خود جنگو یک render برای ما گذاشته که میتونه صفحات ما را render کنه و به کاربر نشون بده، کافیه import کنیم و صداش بزنیم، ضمنا صفحهای که قرار هست به کاربر نشون بدیم را اسمش را میفرستیم برای این تابع، خود جنگو حالا که مسیر template ها را براش معرفی کردیم، میره داخل اون مسیر، دنبال این اسمی که بهش پاس دادی، اگه پیدا کنه، render میکنه و برمیگردونه. برای مثال فرض کنید اسم یکی از این صفحات hello.html هست که ما داخل templates قرارش دادیم.
from django.shortcuts import render
return render(request, 'hello.html')

۱۷. اگر خواستی اطلاعات داخل view را به صفحات بخش template پاس بدی و در template ها کدهای پایتونی بزنی یا به اطلاعات دسترسی داشته باشی، روش های مختلفی برات فراهم شده، که خیلی شیک و تمیز میتونی اینکار و انجامش بدی.
مثلا با {{}} به var ها میتونی دسترسی داشته باشی
مثلا با {%%} میتونی کد پایتون بزنی مثلا شرط بزاری
با فیلتر ها {{|}} میتونی روی متغیر ها کار خاصی انجام بدی
کامنت هم که {##} این هست.
https://docs.djangoproject.com/en/4.2/topics/templates/#module-django.template

۱۸. بریم سراغ model ها خب دیفالت که sqlite3 هست که جنگو ازش استفاده میکنه و وقتی migrate را زدیم ساخت.
هر مدل یک table میشه داخل دیتابیس  - خب model های هر app را داخل بخش models.py مینویسید.
مدل ها انگار همون تعریف table ها هستند، یک کلاس به اسم مدلی که میخواید تعریف میکنید، پیشنهاد میشه که اسم model ها تک کلمه‌ای باشند. از کلاس models.Model ارث بری میکنید، و بعد داخلش میاید class variable هایی که عملا میشه ستونهای model را ذخیره میکنید، و داخل اون هم مقادیر را میزارید.
class Person(models.Model):
    title = models.CharField(max_length=50)
    body = models.TextField()
    created = models.DateTimeField(auto_now=False, auto_now_add=False)
۱۹. خب من الان این کد پایتونی را زدم، اما دیتابیس من sqlite هست و اصن نمیفهمه و قرار هست اونجا بره table ای با این مشخصات model ما ساخته بشه، پس اینجاست که جنگو وارد میشه و ما به جنگو میگیم داداش، بیا برو این model ای که من نوشتم را جوری تغییرش بده که sqlite بفهمه و در دیتابیس ذخیره کن
خب همونطوری که گفتم migration ها به ما کمک میکنند که با دیتابیس سینک باشیم. الان دستور زیر کمک میکنه که اگه model ای به تازگی ایجاد شده یا model ای تغییر کرده و باید دیتابیس اپدیت بشه، تغییرات در دیتابیس اوکی بشه:
python manage.py makemigrations
پس از این دستور وقتی برید داخل پوشه‌ی migrations میبیند که یک initial ای تعریف شده، عملا همون تعریف مدلی که شما کردید را به یک شکلی که sqlite بفهمه در آورده و خودش هم یک ستون id ایجاد کرده که اعداد منحصر به فردی هستند که هی زیاد میشه برای تفکیک کردند بین اینها.
و خب به ازای هر migrateion ای که انجام بشه هی تغییرات را میاد اپدیت میکنه و فایل initial ها همین را نشان میده در پوشهی migrations ، یعنی تغییراتی که در model ها میدید را با استفاده از migrateion ها میفهمه.
۲۰. برای اینکه migration هایی که ایجاد کردید را اعمالشون کنید روی sqlite کافیست از دستور زیر کمک بگیرید. که میاد migration های مختلف را نگاه میکنه و اعمالشون میکنه روی دیتابیس و هر چند تا migration داشته باشید میاد و به ترتیب اعمالشون میکنه روی sqlite
python manage.py migrate
پس دستور makemigration میشه برای تبدیل model به migration که در نقش یک واسطه هست، و دستور migrate میشه برای اعمال migration ها به درون دیتابیس.
۲۱. خب میخوایم مدلهایی که ایجاد میکنیم را بیایم به admin panel اضافه کنیم. برای اینکار کافیست در همون اپی که دارید به admins.py برید. اون مدلتون را به صورت زیر import کنید:
from .models import Person
و بعد به کمک دستور زیر بیاید و رجیستر کنید همین Person را:
admin.site.register(Person)
الان برید داخل admin panel میبینید که مدل شما اضافه کرده. و خب اگه بخواید چیزی اضافه کنید یا کم کنید یا ببینید همه چیز به شکل gui مشخص قابل نمایش هست.
۲۲. خب الان اضافه کردن دیتا به دیتابیس را به کمک پنل ادمین دیدم، سوالی که مطرح هست اینه که چطوری با کد این قضیه را اوکی کنم؟
جنگو برای اینکه بتونید با مدل ها کار کنید به شما یک manager میده به کمک این manager میتونید وصل بشید به مدل مورد نظرتون  و باهاش کار کنید، اسم این manager به صورت دیفالت  objects هست. خب حالا فرض کنید اسم مدل شما Person هست و مثلا داخل view میخواید بیاید با این مدل کار کنید، برای این کار کافیست اول :
from .models import Person 
را داخل views.py بزنید، بعد مثلا داخل یکی از view ها فرضا میخواید با این مدل کار کنید، باید اسم view را بزارید و به دنبالش هم objects در نقش manager را بزارید. حالا مثلا اینجا میخوایم بگیم هر چیزی که در این Person هست را بیا به من برگردون
test = Person.objects.all()
پس تنها نکته‌ای که باید بدونید این هست که objects یک واسطی هست بین برنامهنویس و مدلهای جنگو.
۲۳. الان view زیر میاد کل اطالعات مدل Animal را میگیره، در یک متغیر میریزه، و بع در قالب یک دیکشنری باید پاس بده به template ، داخل کد مربوط به template هم میایم با کلید که test هست به محتوا میرسیم، و کد پایتون داخل html به کمک همون بحث تگ و اینا میزنیم تا دیتایی که از مدل گرفتیم را در قالب template به کاربر برگردونیم، کد زیر کدی هست که تو view زدیم
def home(request):
    all = Animal.objects.all()
    return render(request, 'home.html', {'test': all})
کد زیر کدی هست که تو صفحه ی home.html زدیم:
<html>
<body>
    {% for i in test %}
       title is: <b>{{i.title}}<br></b>
       body is: {{i.body}}<br>
       created tims is: {{i.created}}<br>
       <br><br><br>
    {% endfor %}
</body>    
</html>
۲۴. بحث ارثبری: برای اینکه از کدهای تکراری در template ها جلوگیری بشه از روش زیر کمک میگیریم.:
میایم فایل html پایه‌ای مثل base.html میسازیم، بعد کدهای html که مشترک هستند را توش میزنیم، اونجاهایی که میخوایم کدهای جاهایی دیگه را بیاریم با {%block YE_ESM%} باز میکنیم و بعدش {% endblcok %} میزاریم. 
حالا میریم توی html ای که کدهای خودش را زدیم و میخوایم بعدا به اون base.html اکستندش کنیم، اول اون فایل این خط را اضافه میکنیم: {% 'extends 'base.html %}، این به این html فعلیمون میگه باید بری کدهاتو به کجا extend کنی. از این به بعد میفهمه باید بره کدهای این بخش را در اون بخش کپی کنه. فقط یادت باشه که در این html فعلی کدهاییت که میخوای بره تو اون بلاک کپی بشه را باید بین در همین فایل بین همین دو تا بلاک که گذاشتم بزاری. خطوط زیر میشه چیزی که تو html فعلیت میزنی
{% extends 'base.html' %}
	{% block test %}
		#your_code
	{% endblock %}
از اون طرف در فایل base.html هم فارق از کدهایی که داری هر جایی خواستی این کدها کپی شه چون اسم بلاکش test هست باید این را بزاری : 
{% block test %}	{% endblock %}
خودش میره و بین این دو تا کدهای اون فایل و میزاره
تعداد اینها نامحدود میتونه باشه و ترتیبشون هم اهمیت نداره

۲۵. لینک bootstrap را باید بزاریم داخل تگ head جاش هم مهم نیست.
اگه خواستی در صفحه‌ای یک صفحه‌ی دیگر را کاملا بیاریش، از include باید استفاده کنی. یعنی شما یک صفحه را کاملا میای و include اش میکنی تو صفحه ای که داشتی برای این کار کافیه در صفحه‌ی html از خط زیر استفاده کنی، و هر صفحه‌ای که خواستی را بیاری، در این صورت وقتی به اینجا برسه کل محتوای اون صفحه‌ی html را میاد و include میکنه:
{% include   'navbar.html'%}

۲۶. بحث read: برای گرفتن اطلاعات از طریق URL چیزی داریم به اسم URL dispather که خب قرار هست شما بیاید دیتا بگیرید، نکته‌ای که هست شما قرار هست دیتا بگیری، پس تو url ای دیتا قرار هست بیاد:
path('detail/<int:id>', views.detail)
فیلم مربوط به گرفتن اطلاعات از url ای که کاربر زده و نشان دادن محتوای مرتبط با اون.
ابتدا اومدیم id ها را ارسال کردیم، 
بعد در داخل view هامون id ارسال شده را گرفتیم 
و بر اساس اون ایدی به مدل وصل شدیم، اطلاعاتش را گرفتیم.
سپس اطلاعات را به template پاس دادیم،
و سپس در صفحات html اومدیم و اطلاعاتی که گرفته بودیم را نمایش دادیم.
در نهایت هم صفحه‌ی اصلی را لینکش کردیم.

۲۷. بهتر کردن لینک دادن
به جای خط زیر :
title is: <a href="/home/detail/{{i.id}}">{{i.title}}</a>
از خط زیر کمک میگیریم:
title is: <a href="{% url 'details' i.id %}">{{i.title}}</a>


۲۸.  بحث delete حذف اطلاعات از دیتابیس
۲۹. نمایش پیغام به کاربر ، سه چیز که در تنظیمات باشه یعنی از message ها پشتیبانی میکنه، در بخش installed app قسمت messages ، در بخش middleware یک messageMiddleWare و در بخش template ها هم context proccessor messge ها هست. اگه نمیخوایید از message ها استفاده کنید، حذفشوون کنید.
برای استفاده کردن اول import کنید:
from django.contrib import messages
بعد متناسب با سطح message ای که دوست دارید پیغامتون را کامل کنید.
فقط نکته ‌ای که خب شما پیغامی که تولید میکنی یک جایی باید باشه که این را نشان بده، در واقع کد html اش مدنظر هست. برای این کار باید از نمونه کد زیر ککمک بگیرید.
{% if messages%}
{% for msg in messages%}
    <p class="alert alert-{{msg.tags}}">{{msg}}</p>
{% endfor %}
{% endif %}
۳۰. بحث create ساختن اطلاعات جدید ، خب میشه به کمک form ها اطلاعات جدید را دریافت کرد فقط نکته‌ای که هست این فرمها را میشه به کمک همون html اوکی کرد ولی خب صحت سنجیشون را سخت میکنه و کد زیادی باید بزنید لذا به جاش میایم از form ها در داخل جنگو استفاده میکنیم. عملا مثل این هست که میخوایم insert کنیم داده ی جدید را.
خب get از طریق url ارسال میکنه و post از طریق بدنه‌ی http request
کار با formها در django خیلی شبیه به models ها هست.
برای ساخت form هم بهتره برای هر app فرمهاشو در همون app تعریف کنید، برای این کار از forms.py استفاده میکنیم، یعنی forms.py را میسازیم و بعد کدهای فرم مورد نظر را داخل اون مینویسیم.
خب اگه خواست فرم را بسازی، مثل همون مدل میای class تعریف میکنی، و اسمها کمل کیس باشه و همچنین بهتر هست اخرش اسم Form را بزاری به عنوان یک حرکت مرسوم. و باید از کلاس forms.Form ارث بری کنه، و خب اینجا هم اسم فیلدهای فرم را میزاری و نوع هاشون را مشخص میکنی (خب منطقا جنس و ایناشون باید با مدل ای که احیانا برای اون داری دیتا میگیری همخوانی داشته باشه)

۳۰. توضیحات بیشتر بحث forms: در جنگو به شکل دیفالت تمامی فیلدهایی که با forms میسازید اجباری در نظر گرفته میشوند، یعنی بعدا که کاربر بخواد وارد کنه، حتما باید مقدارها را وارد کند. که خب اگه بخواید اینا عوض کنید و یا کلا اپشنهای مختلف title های فرمها را دست کاری کنید، باید مقدار required را false بزارید. کلا دست کاری کردن اسم فرم ها و... و هر تغیری با فرستادن ارگومان های مختلف هنگام ایجاد title ها در کلاس form هست یعنی:
class CreatePersonForm(forms.Form):
    title = forms.CharField(label="hasan", required=false)
۳۱. خب حالا نکته ای که هست اگه طرف create و زد یعنی به هر نحوی به صفحه‌ی create رفت، باید چه کنیم؟ دو اتفاق اینجا رخ میده: ۱. ممکن است دفعه‌ی اولی هست که وارد این صفحه شده و باید فرم را نشان بدیم صرفا بخوایم صفحه را بهش نشون بدیم، ۲.ممکن است بخوایم دیتایی که وارد کرده داخل فرم را ازش بگیریم.
خب در حالت اول form با متود GET طرف هستیم و در حالت دوم هم میتوانیم هم با متود GET هم با متود POST طرف باشیم. نکته‌ای که مطرح هست فرض را بر POST میگذاریم یعنی دیتاها با متود post ارسال میشوند.
پس داخل view اولین کاری که باید انجام بدیم این هست که طرف در کدوم وضعیت داره درخواست میفرسته، که این را از روی request.method با توضیح بالا میشه فهمید این که POST هست یا GET . که اگر GET بود یعنی صفحه را باید براش return کنیم، و اگر POST بود یعنی باید دیتایی که وارد کرده را ازش بگیریم.
ضمنا برای اینکه نوع form را مشخص کنی، در همون فایل html باید نوعش و مشخص کنی،
یک بحث دیگه‌ای هم این فرمها دارند که بهشون میگند actions که یعنی این فرمی که تکمیل شد کجا باید ارسال شود، یا باید با url اوکی کنید، که یعنی بفرست به این url که میگم، حالا یا ادرس میدی یا از اون name= که برای url ها تعیین کردیم استفاده میکنی که در زیر مثالش اومده:
action="{% url 'create' ''%}"
و اگر هم که جلوی action را یک "" خالی بزاری، یعنی از همونجایی که اومدی برگرد به همونجا، یعنی مثلا اگر در view شما یک صفحه‌ی cretea را به طور مثال صدا زدی،  اطلاعاتی که کاربر داره submit میکنه، برمیگرده به همون view.
در نهایت بخش فرم در فایل html مثلا برای crete به شکل زیر میشه، اون قسمت novalidate اعتبارسنجی مرورگر را متقوف میکنه چون ما میخوایم اعتبار سنجی را خودمون اوکی کنیم.
ضمنا اون خط csrf هم  همیشه برای form ها در جنگو میزاریم که ما را از حمله ی csrf هکرها مصون نگه میداره، اگر نزارید فرم به درستی کار نمیکنه:
<form method="post" novalidate>
    {% csrf_token %}
    {{form.as_p}}
    <input type="submit" value="send">
</form>
۳۲. خب تا مرحله بالا را رفتیم فرض کن حالا میخوایم مقادیر وارد شده توسط کاربر را صحت سنجی کنیم، پس به view  میریم در اونجا میریم سراغ بخشی که کاربر با post درخواست ارسال کرده، و form.is_valid را اوکی میکنیم، خب این صحت سنجی بر اساس اپشنها و شکلی هست که برای تایتل ها در فرم مشخص کردی، مثلا اگر اجباریش را تعیین نکرده باشی به صورت دیفالت اجباری هست، پس وقتی فرم را فیلدیش که اجاباری هست خالی بفرستی، سر همین بخش is_valid با خطا مواجه میشه و جنگو میگه معتبر نیست چون اجبار بوده که بزنی. یا ممکنه تایپی که زده با تایپی که انتظار داشته متفاوت باشه. و اگر خطا باشه خود django خطا به ما میده.
۳۳. پس از صحت سنجی که جنگو انجام داد و اوکی شد، اون دیتاهای سالم و تمیز را از طریق یک دیکشنری به اسم cleaned_data. دسترس هست یعنی شما همون متغیری که فرم را درش ریخته بودی، و با is_valid اعتبار سنجیش کردی، اگه خطایی نباشه دیتاها در cleaned_data.تحت یک دیکشنری که کلید ها تایتل ها هستند و value هم مقادیری که کاربر زده در دسترس خواهد بود.
۳۴. پس از این که دیکشنری به دستت رسید دیگه کافیه بری ارتباط بگیری با مدل به کمک objects به صورت زیر که در اون اسم ارگومان ها میشه اسم همون تایتل های model و مقادیر هم میشه همین مقادیری که در دیکشنری دیتاهای تمیز شده ذخیره کردیم. در اینجا چون اسم تایتل های form و اسم تایتل های model یکسان بوده اسم کلید ها با اسم فیلدهای model که داریم پاس میدیم یکی شده.
Person.objects.create(title=cd['title'], body=cd['body'], created=cd['created'])
در نهایت بعد از create کردن هم کافیست پیغام را نشان بدیم و در نهایت return کنیم به صفحه‌ی درستش مثل home
۳۵. خب تنها چیزی که باقی مانده update کردن هست. برای اپدیت کردن هم ما باید مثل delete که از id کمک گرفتیم اینجا هم از id کمک بگیریم برای اینکه اون مولفه‌ی خاص را تغییرش بدیم.
۳۶. خب یک کار خوبی که جنگو کرده ما در بخش قبلی خودمون اومدیم form را به model وصلش کردیم، یعنی خودمون دستی تایتل ها را از یک جنس دادیم و بعد پاس دادیم بهش و این صوبتا، اما در جنگو یک کار خوبی که میشه انجام داد این هست که از modeform ها استفاده کنیم که کارش این هست که به شکل اتوماتیک میاد بر اساس یک مدل برای شما فرمش را ایجاد میکنه.
برای این کار باید یک شکل دیگری از فرم ایجاد بشه، یعنی کاری به روشی که دفعه‌ی قبیل فرم را ایجاد کردیم نداریم، از یک روش دیگه استفاده میکنیم به صورت زیر:
همون فایل forms.py که ساخته بودید کمکاکان میسازیدش، و اینبار مدل مدنظرتون را هم import میکنید. 
اول یک کلاس تعریف میکنید که از ModelForm که در کتابخانه ی زیر هست ارث بری میکند اسم را مطابق با همان کانونشنی که گفتم ایجاد میکنیم:
from django import forms
class ArticleForm(forms.ModelForm):
حالا باید یک class Meta که دقیقا همین اسم هست، حاوی اطلاعات بیشتر درباره‌ی این کلاس هست داخلش ایجاد کنیم، و در اون اول بگیم که این فرم برای کدام model هست و در بخش fields هم میایم مشخص میکنیم، که کدام فیلدهای model را میخوایم براش فرم درست کنیم. 
اگر تعدادی از فیلد ها مد نظر بود filelds به صورت زیر میشه:
fields = ('title', 'body', 'created')
اگر همه‌ی فیلد های اون model مدنظرت بود به صورت زیر میشه:
fields = '__all__'
درنهایت مقایسه ی دو شکل مختلف الان میشه شکل زیر:
class CreatePersonForm(forms.Form):
    title = forms.CharField()
    body = forms.CharField()
    created = forms.DateTimeField()
    
class UpdatePersonForm(forms.ModelForm):
    class Meta:
        model = Animal
        fields = ('title', 'body', 'created')
کار تمومه حالا تنها کاری که دیگه لازم هست این که نمونه از این فرم جدید درست کنی و باهاش کار کنی مثل دفعه‌ی قبلی:
form = UpdateAnimalForm()
۳۷. خب اولین نکته اینکه ما در update بالاخره یه سری دیتا از قبل هست مثل create نیست که خالی باشه، پس بهتره فرمی که برای update برای کاربر باز میشه، حاوی دیتاهای قبلی باشه، که هر کدوم را کاربر تصمیم گرفت تغییر بده، بتونه تغییرشون بده.
برای این کار خب باید موقعی که میاد تو update از روی id به model وصل شیم و دیتای اون id را بکشیم بیرون، سپس با کلمه ی کلیدی instance پاسش بدیم به فرمی که به کاربر میخواستیم بدیم یعنی مثلا خط زیر 
form = UpdateAnimalForm()
میشه خطوط زیر:
animal = Animal.objects.get(animal_id)
form = UpdateAnimalForm(instance=animal)
۳۸. خب میریم سر بخش post مربوط به این update، خب اولا که اطلاعات request.POST را پاس میدیم به همون modelform امون و بعد هم چک کردن را داریم که is_valid را داریم. فقط توجه کن اینجا چون از ModelForm به جای Form معمولی استفاده کردیم، کارمون راحتتر هست یعنی اگر valid بود، تنها کاری که باید رخ بده این هست که اطلعات را ذخیره کنیم، دیگه اینکه از cleaned_data استفاده کنیم و  کدوم فیلد model را به کدوم فیلد form وصل کنیم اینجا موضوعیت نداره و اگه معتبر بود صرفا با خط زیر کار اوکی هست، دقت کن این ربطی به update نداره ها،‌اینجا چون از model form استفاده کردیم اینطوری شد، اگه در create هم از model form استفاده میکردی همینطوری اوکی بود.
form.save()
فقط توجه کن برای اینکه به درستی بتونه save کنه در خط زیر که قرار هست دیتا را بفرسته باید instance ای که دفعه‌ی قبلی هم براش فرستادید را بفرستید. یعنی خط زیر 
form = UpdateAnimalForm(request.POST)
درستش خط زیر هست:
form = UpdateAnimalForm(request.POST, instance=animal)
در واقع در update باید در کنار دیتاییی که میاد instance را هم بفرستید. چه برای نمایش چه بعدا برای اپدیت کردن و save کردن مقادیر.
مهم : اگر instance را نزارید میره create میکنه، instance میزازیم که نشون بدیم یک ابجکتی که قبلا وجود داشته را باید بره و مقادیر جدید را به جای اون یادداشت کنه، اگر instance را ننویسیم به اشتباه میفته. و میره یک نمونه‌‌ی جدید با دیتاهایی که کاربر داده میسازه.
۳۹. مدیریت کردن کاربران
خب هدفمون این هست که register کردن login کردن و logout کردن کاربران را اوکی کنیم.
برای این کار نیاز به یک app جدید داریم.
خب ساخت کاربر superuser را که قبلا دیده بودیم که دسترسی به ادمین پنل داره
الان میخوایم کاربرهای عادی که چنین دسترسی ای ندارند را توضیحشتون بدیم
خب خود جنگو یک مدل user داره که یک سری فانکشنالیتی اولیه را داره و تو ادمین پنل هم حتما دیدید، اما در دنیای واقعی از این استفاده نمیشه، و میان اینا پاکش میکنند و مدل خودشون را تعریف میکنند، ولی چون دردسر هایی داره فعلا با همین مدل پایه کار و پیش میبریم.
اما نکته ای که هست این بحث register کردن login کردن و logout کردن در هیچ کدام از اینها تغییر خاصی نداره و چه مدل کاستومایز شده چه مال جنگو یکی هست
در مدل مرسوم جنگو authentication به کمک همین username , password هست.  
کاربر به غیر از یوزرنم و پسورد، اسم و فامیل ، ایمیل هم میتونه داشته باشه، که البته در authenticatin تنها چیزی که موثر هست همان username , password هستش
پرمیژن هایی هم که هر کاربر داره active هست که میگه کاربر فعال باشه یا نه، اگه غیرفعال بشه دیتاش وجود داره ولی نمیتونه دسترسی داشته باشه. staff status اگر فعال باشه به کاربرهایی میگند که میتونه به admin site دسترسی داشته باشه.
بحث supersuer که دسترسی های خیلی بالاست که میتونه به شل چنگو مثلا وصل بشه و ایتو چیزا
همونطوری که گفتم مدل یوزر جنگو را هم میشه به طور کامل جایگزین کرد، هم میشه تغییرش داد.
۴۰. خب بریم برای ساخت app مربوط به کاربران، 
python manage.py startapp accounts
اضافه کردن به installed app در setting
و بقیه فرایند هاش مثل همون home هست، فقط اینجا ما سه تا url داریم register , login , logout

۴۱. خب ابتدا بحث create کردن user، چون گفتیم از مدل همون جنگو میخوایم استفاده کنیم اول user زیر را import میکنیم:
from django.contrib.auth.models import User
User.objects.create_user('USERNAME', 'EMAIL', 'PASSWORD' ")
بقیش یک فرایند مثل create کردن هست. که شما میخوای اینا create کنی ، یعنی باید سه مقدار بالا را از طریق یک form معمولی از کاربر بگیری و بعد بیایی مقادیری که گرفتی را باهاش user را بسازی
فقط نکته ی اضافه‌ای که مطرح هست این هست که با دستور بالا برای user  ای که ایجاد میشه فقط میشه مقادیر username , passowrd , emial را داد، اگر خواستی مقادیری مثل first_name  یا last_name و اون پرمیژن ها را هم تنظیم کنی، باید مقدار بالا را در یک متغیر بریزی و بعد با اون متغیر به اون مقادیر مورد نظرت دسترسی داشته باشی دقت کن که املای last_name و first_name در مدل دقیقا به همین صورت هست، اینطوری نباشه save نیمکنه و در نهایت واسه‌ی این بخش حتما باید save را هم بزنی. الان کد زیر کد کامل بخش view هست.
def user_register(request):
    if request.method == 'POST':
        form = RegisterUserForm(request.POST)
        if form.is_valid():
            cd = form.cleaned_data
            user = User.objects.create_user(cd['username'], cd['email'], cd['password'])
            user.last_name = cd['last_name']
            user.save()
            messages.success(request, 'successfully', "success")
            return redirect('home')            
    else:
        form = RegisterUserForm()
    return render(request, 'register.html', {'form': form})

پس حواست باشه اون create_user خودش به صورت اتوماتیک save را میزنه ولی اون ویژگی ها که با متغیر خواستی مقداردهیشون کنی خودت باید دستی save ‌را براشون بزنی و حتما با همین املا که گفتم.
۴۲. برای login کردن از دو متود authenticate , login استفاده میشه. که در کتابخانه زیر هست:
from django.contrib.auth import authenticate, login
خب بخش authenticate کارش این هست که میاد چک میکنه این username , password ای که کاربر زده و شما گرفتینش و دارید پاس میدید به این متود، چک کنه ببینه با هم مطابقت دارند یا نه و اشتباه نباشه. بعد از این که authenticate به درستی کار کرد، میشه از متود login برای  login کاربر استفاده کرد.
خب متود authenticate دو تا ورودی میگیره username , passoword که خب این به اون قضیه برمیگرده که گفتیم احرازهویت کاربر در جنگو با user , pass هست. این متود اگر تطابق بین این دو وجود داشته باشد، میره و اون کاربر را خروجی میده که ما میتونیم مثلا بریزیمش داخل user، اگر هم معتبر نباشه که مقدار None داخل user خواهد رفت.
پس اگه اوکی باشه و مقدار درست در user ریخته بشه کار تموم هست، , و با متود login میایم و user را که معتبر بوده را میریزیم داخل ریکوئست.
این که این ریختن در ریکوئست به چه درد ما میخوره فعلا تو ذهنت باشه تا بعدا با هم حرف بزنیم.
۴۳. برای logout کردن از متود logout در کتابخانه ی زیر کمک میگیریم
from django.contrib.auth import logout
تنها کاری که باید انجام بدید این هست که request را بدید به این متود کل کدش:
def user_logout(request):
    logout(request)
    messages.success(request, "successfully", "success")
    return redirect('home')
همونطوری که گفتم متود login کاری که میکرد میمد user را میریخت داخل request و متود logout خلاف اون را انجام میده یعنی user را از request درش میاره به همین راحتی
